// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Concepts from "./Concepts.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function takeWhile(xs, f) {
  if (!xs) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  var y = f(x);
  if (y === undefined) {
    return [
            /* [] */0,
            {
              hd: x,
              tl: xs$1
            }
          ];
  }
  var match = takeWhile(xs$1, f);
  return [
          {
            hd: Caml_option.valFromOption(y),
            tl: match[0]
          },
          match[1]
        ];
}

function parseParagraph(it) {
  var makeRecParser = function (k, delim, tag) {
    return function (it) {
      return it.split(delim.concat(delim)).flatMap(function (x, i) {
                  var x$1 = k(x.replaceAll(" ".concat(delim), delim));
                  if (i === 0) {
                    return x$1;
                  } else {
                    return Belt_Array.concatMany([
                                [{
                                    TAG: "Tag",
                                    _0: tag
                                  }],
                                x$1
                              ]);
                  }
                });
    };
  };
  var parseRec = makeRecParser(makeRecParser(makeRecParser(makeRecParser(makeRecParser(makeRecParser((function (x) {
                              return [{
                                        TAG: "Final",
                                        _0: {
                                          TAG: "Plain",
                                          _0: x
                                        }
                                      }];
                            }), "/", "Oblique"), "*", "Boldface"), "`", "Monospaced"), "!", "Highlighted"), "_", "Underscored"), "~", "Strikethrough");
  var tokens = it.split("\"\"").flatMap(function (token, i) {
        if (i % 2 === 0) {
          return parseRec(token);
        } else {
          return [{
                    TAG: "Final",
                    _0: {
                      TAG: "SEval",
                      _0: token
                    }
                  }];
        }
      });
  var splitAtFirst = function (ts, tag) {
    if (!ts) {
      return PervasivesU.failwith("not found");
    }
    var ts$1 = ts.tl;
    var t = ts.hd;
    if (Caml_obj.equal(t, {
            TAG: "Tag",
            _0: tag
          })) {
      return [
              /* [] */0,
              ts$1
            ];
    }
    var match = splitAtFirst(ts$1, tag);
    return [
            {
              hd: t,
              tl: match[0]
            },
            match[1]
          ];
  };
  var f = function (ts) {
    if (!ts) {
      return /* [] */0;
    }
    var x = ts.hd;
    if (x.TAG !== "Tag") {
      return {
              hd: x._0,
              tl: f(ts.tl)
            };
    }
    var t = x._0;
    var match = splitAtFirst(ts.tl, t);
    return {
            hd: {
              TAG: "Tagged",
              _0: t,
              _1: f(match[0])
            },
            tl: f(match[1])
          };
  };
  return f(Core__List.fromArray(tokens));
}

function parseDocument(it) {
  var takeAllIndented = function (indent, lines) {
    if (!lines) {
      return [
              /* [] */0,
              /* [] */0
            ];
    }
    var lines$1 = lines.tl;
    var line = lines.hd;
    if (!(line === "" || line.startsWith(" ".repeat(indent)))) {
      return [
              /* [] */0,
              {
                hd: line,
                tl: lines$1
              }
            ];
    }
    var line$1 = line.substring(indent, line.length);
    var match = takeAllIndented(indent, lines$1);
    var lines$2 = match[1];
    var head = match[0];
    if (head === /* [] */0 && line$1 === "") {
      return [
              /* [] */0,
              {
                hd: line$1,
                tl: lines$2
              }
            ];
    } else {
      return [
              {
                hd: line$1,
                tl: head
              },
              lines$2
            ];
    }
  };
  var parse = function (lines) {
    if (!lines) {
      return /* [] */0;
    }
    var lines$1 = lines.tl;
    var line = lines.hd;
    if (line.startsWith("- ")) {
      var line$1 = line.substring(2, line.length);
      var match = takeAllIndented(2, lines$1);
      var token = {
        TAG: "ListElement",
        _0: {
          ordered: false,
          content: parseDocument$1({
                hd: line$1,
                tl: match[0]
              })
        }
      };
      return {
              hd: token,
              tl: parse(match[1])
            };
    }
    if (line.startsWith(". ")) {
      var line$2 = line.substring(2, line.length);
      var match$1 = takeAllIndented(2, lines$1);
      var token$1 = {
        TAG: "ListElement",
        _0: {
          ordered: true,
          content: parseDocument$1({
                hd: line$2,
                tl: match$1[0]
              })
        }
      };
      return {
              hd: token$1,
              tl: parse(match$1[1])
            };
    }
    if (line.startsWith("> ")) {
      var line$3 = line.substring(2, line.length);
      var match$2 = takeAllIndented(2, lines$1);
      var token$2 = {
        TAG: "Final",
        _0: {
          TAG: "Blockquote",
          _0: parseDocument$1({
                hd: line$3,
                tl: match$2[0]
              })
        }
      };
      return {
              hd: token$2,
              tl: parse(match$2[1])
            };
    }
    if (!line.startsWith("| ")) {
      if (line === "|-") {
        return {
                hd: {
                  TAG: "TableElement",
                  _0: "Break"
                },
                tl: parse(lines$1)
              };
      } else if (line === "") {
        return {
                hd: "Empty",
                tl: parse(lines$1)
              };
      } else {
        return {
                hd: {
                  TAG: "ParagraphLine",
                  _0: line
                },
                tl: parse(lines$1)
              };
      }
    }
    var line$4 = line.substring(2, line.length);
    var match$3 = takeAllIndented(2, lines$1);
    var token$3 = {
      TAG: "TableElement",
      _0: {
        TAG: "Cell",
        _0: parseDocument$1({
              hd: line$4,
              tl: match$3[0]
            })
      }
    };
    return {
            hd: token$3,
            tl: parse(match$3[1])
          };
  };
  var makeTable = function (es) {
    var collectRows = function (_row, _es) {
      while(true) {
        var es = _es;
        var row = _row;
        if (es) {
          var cell = es.hd;
          if (typeof cell !== "object") {
            var row$1 = Core__List.reverse(row);
            return {
                    hd: row$1,
                    tl: collectRows(/* [] */0, es.tl)
                  };
          }
          _es = es.tl;
          _row = {
            hd: cell._0,
            tl: row
          };
          continue ;
        }
        var row$2 = Core__List.reverse(row);
        return {
                hd: row$2,
                tl: /* [] */0
              };
      };
    };
    return collectRows(/* [] */0, es);
  };
  var groupLines = function (_ts) {
    while(true) {
      var ts = _ts;
      if (!ts) {
        return /* [] */0;
      }
      var e = ts.hd;
      if (typeof e !== "object") {
        _ts = ts.tl;
        continue ;
      }
      switch (e.TAG) {
        case "ParagraphLine" :
            var match = takeWhile(ts.tl, (function (t) {
                    if (typeof t !== "object" || t.TAG !== "ParagraphLine") {
                      return ;
                    } else {
                      return t._0;
                    }
                  }));
            var es_0 = e._0;
            var es_1 = match[0];
            var es = {
              hd: es_0,
              tl: es_1
            };
            return {
                    hd: {
                      TAG: "Paragraph",
                      _0: parseParagraph(Core__List.toArray(es).join(" "))
                    },
                    tl: groupLines(match[1])
                  };
        case "ListElement" :
            var match$1 = e._0;
            if (match$1.ordered) {
              var match$2 = takeWhile(ts.tl, (function (t) {
                      if (typeof t !== "object") {
                        return ;
                      }
                      if (t.TAG !== "ListElement") {
                        return ;
                      }
                      var match = t._0;
                      if (match.ordered) {
                        return match.content;
                      }
                      
                    }));
              var es_0$1 = match$1.content;
              var es_1$1 = match$2[0];
              var es$1 = {
                hd: es_0$1,
                tl: es_1$1
              };
              return {
                      hd: {
                        TAG: "List",
                        ordered: true,
                        content: es$1
                      },
                      tl: groupLines(match$2[1])
                    };
            }
            var match$3 = takeWhile(ts.tl, (function (t) {
                    if (typeof t !== "object") {
                      return ;
                    }
                    if (t.TAG !== "ListElement") {
                      return ;
                    }
                    var match = t._0;
                    if (match.ordered) {
                      return ;
                    } else {
                      return match.content;
                    }
                  }));
            var es_0$2 = match$1.content;
            var es_1$2 = match$3[0];
            var es$2 = {
              hd: es_0$2,
              tl: es_1$2
            };
            return {
                    hd: {
                      TAG: "List",
                      ordered: false,
                      content: es$2
                    },
                    tl: groupLines(match$3[1])
                  };
        case "TableElement" :
            var match$4 = takeWhile(ts.tl, (function (t) {
                    if (typeof t !== "object" || t.TAG !== "TableElement") {
                      return ;
                    } else {
                      return t._0;
                    }
                  }));
            var es_0$3 = e._0;
            var es_1$3 = match$4[0];
            var es$3 = {
              hd: es_0$3,
              tl: es_1$3
            };
            return {
                    hd: {
                      TAG: "Table",
                      _0: makeTable(es$3)
                    },
                    tl: groupLines(match$4[1])
                  };
        case "Final" :
            return {
                    hd: e._0,
                    tl: groupLines(ts.tl)
                  };
        
      }
    };
  };
  var parseDocument$1 = function (lines) {
    var lines$1 = parse(lines);
    return groupLines(lines$1);
  };
  return parseDocument$1(Core__List.fromArray(it.split("\n")));
}

function $$escape(x) {
  return x.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#39;");
}

function spansToString(spans) {
  return Core__List.toArray(Core__List.map(spans, spanToString)).join("");
}

function spanToString(span) {
  switch (span.TAG) {
    case "Tagged" :
        var tag = Concepts.Tag.toString(span._0);
        return "<" + tag + ">" + spansToString(span._1) + "</" + tag + ">";
    case "SEval" :
        var tag$1 = "code";
        return "<" + tag$1 + ">" + $$escape(span._0) + "</" + tag$1 + ">";
    case "Plain" :
        return $$escape(span._0);
    
  }
}

function blockToString(block) {
  switch (block.TAG) {
    case "Paragraph" :
        return "<p>" + spansToString(block._0) + "</p>";
    case "List" :
        var tag = block.ordered ? "ol" : "ul";
        var content = Core__List.toArray(Core__List.map(Core__List.map(block.content, documentToString), (function (x) {
                      return "<li>" + x + "</li>";
                    }))).join("");
        return "<" + tag + ">" + content + "</" + tag + ">";
    case "Blockquote" :
        var tag$1 = "blockquote";
        var content$1 = documentToString(block._0);
        return "<" + tag$1 + ">" + content$1 + "</" + tag$1 + ">";
    case "Table" :
        var content$2 = Core__List.toArray(Core__List.map(block._0, tableRowToString)).join("");
        return "<table>" + content$2 + "</table>";
    case "BEval" :
        return PervasivesU.failwith("todo");
    
  }
}

function tableRowToString(content) {
  var content$1 = Core__List.toArray(Core__List.map(content, tableCellToString)).join("");
  var tag = "tr";
  return "<" + tag + ">" + content$1 + "</" + tag + ">";
}

function tableCellToString(content) {
  return "<td>" + documentToString(content) + "</td>";
}

function documentToString($$document) {
  if ($$document) {
    var p = $$document.hd;
    if (p.TAG === "Paragraph" && !$$document.tl) {
      return spansToString(p._0);
    }
    
  }
  return Core__List.toArray(Core__List.map($$document, blockToString)).join("");
}

export {
  parseDocument ,
  documentToString ,
}
/* No side effect */
