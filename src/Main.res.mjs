// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Concepts from "./Concepts.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function parseParagraph(it) {
  var makeRecParser = function (k, delim, tag) {
    return function (it) {
      return it.split(delim.concat(delim)).flatMap(function (x, i) {
                  var x$1 = k(x.replaceAll(" ".concat(delim), delim));
                  if (i === 0) {
                    return x$1;
                  } else {
                    return Belt_Array.concatMany([
                                [{
                                    TAG: "Tag",
                                    _0: tag
                                  }],
                                x$1
                              ]);
                  }
                });
    };
  };
  var parseRec = makeRecParser(makeRecParser(makeRecParser(makeRecParser(makeRecParser(makeRecParser((function (x) {
                              return [{
                                        TAG: "Final",
                                        _0: {
                                          TAG: "Plain",
                                          _0: x
                                        }
                                      }];
                            }), "/", "Italic"), "*", "Strong"), "~", "Delete"), "!", "Highlight"), "_", "Underline"), "`", "Monospace");
  var tokens = it.split("\"\"").flatMap(function (token, i) {
        if (i % 2 === 0) {
          return parseRec(token);
        } else {
          return [{
                    TAG: "Final",
                    _0: {
                      TAG: "Eval",
                      _0: token
                    }
                  }];
        }
      });
  var splitAtFirst = function (ts, tag) {
    if (!ts) {
      return PervasivesU.failwith("not found");
    }
    var ts$1 = ts.tl;
    var t = ts.hd;
    if (Caml_obj.equal(t, {
            TAG: "Tag",
            _0: tag
          })) {
      return [
              /* [] */0,
              ts$1
            ];
    }
    var match = splitAtFirst(ts$1, tag);
    return [
            {
              hd: t,
              tl: match[0]
            },
            match[1]
          ];
  };
  var f = function (ts) {
    if (!ts) {
      return /* [] */0;
    }
    var x = ts.hd;
    if (x.TAG !== "Tag") {
      return {
              hd: x._0,
              tl: f(ts.tl)
            };
    }
    var t = x._0;
    var match = splitAtFirst(ts.tl, t);
    return {
            hd: {
              TAG: "Tagged",
              _0: t,
              _1: f(match[0])
            },
            tl: f(match[1])
          };
  };
  return f(Core__List.fromArray(tokens));
}

function $$escape(x) {
  return x.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#39;");
}

function spansToString(spans) {
  return Core__List.toArray(Core__List.map(spans, spanToString)).join("");
}

function spanToString(span) {
  switch (span.TAG) {
    case "Tagged" :
        var tag = Concepts.Tag.toString(span._0);
        return "<" + tag + ">" + spansToString(span._1) + "</" + tag + ">";
    case "Eval" :
        var tag$1 = "code";
        return "<" + tag$1 + ">" + $$escape(span._0) + "</" + tag$1 + ">";
    case "Plain" :
        return $$escape(span._0);
    
  }
}

export {
  parseParagraph ,
  $$escape ,
  spansToString ,
  spanToString ,
}
/* No side effect */
