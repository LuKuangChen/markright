// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Concepts from "./Concepts.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function parseDocument(it) {
  var takeAllIndented = function (indent, lines) {
    if (!lines) {
      return [
              /* [] */0,
              /* [] */0
            ];
    }
    var lines$1 = lines.tl;
    var line = lines.hd;
    if (!(line === "" || line.startsWith(" ".repeat(indent)))) {
      return [
              /* [] */0,
              {
                hd: line,
                tl: lines$1
              }
            ];
    }
    var match = takeAllIndented(indent, lines$1);
    return [
            {
              hd: line.substring(indent, line.length),
              tl: match[0]
            },
            match[1]
          ];
  };
  var parse = function (lines) {
    if (!lines) {
      return /* [] */0;
    }
    var lines$1 = lines.tl;
    var line = lines.hd;
    if (line.startsWith("- ")) {
      line.substring(2, line.length);
      var match = takeAllIndented(2, lines$1);
      var token_1 = PervasivesU.failwith("todo");
      var token = {
        TAG: "ListItem",
        ordered: false,
        content: token_1
      };
      return {
              hd: token,
              tl: parse(match[1])
            };
    }
    if (line.startsWith("# ")) {
      line.substring(2, line.length);
      var match$1 = takeAllIndented(2, lines$1);
      var token_1$1 = PervasivesU.failwith("todo");
      var token$1 = {
        TAG: "ListItem",
        ordered: true,
        content: token_1$1
      };
      return {
              hd: token$1,
              tl: parse(match$1[1])
            };
    }
    if (line.startsWith("> ")) {
      line.substring(2, line.length);
      var match$2 = takeAllIndented(2, lines$1);
      var token$2 = {
        TAG: "Final",
        _0: {
          TAG: "Blockquote",
          _0: PervasivesU.failwith("todo")
        }
      };
      return {
              hd: token$2,
              tl: parse(match$2[1])
            };
    }
    if (line.startsWith("| ")) {
      line.substring(2, line.length);
      var match$3 = takeAllIndented(2, lines$1);
      var token_1$2 = PervasivesU.failwith("todo");
      var token$3 = {
        TAG: "TableElement",
        col: 0,
        content: token_1$2
      };
      return {
              hd: token$3,
              tl: parse(match$3[1])
            };
    }
    if (line.startsWith("|| ")) {
      line.substring(3, line.length);
      var match$4 = takeAllIndented(3, lines$1);
      var token_1$3 = PervasivesU.failwith("todo");
      var token$4 = {
        TAG: "TableElement",
        col: 1,
        content: token_1$3
      };
      return {
              hd: token$4,
              tl: parse(match$4[1])
            };
    }
    if (!line.startsWith("||| ")) {
      if (line === "|-") {
        return {
                hd: "TableHLine",
                tl: parse(lines$1)
              };
      } else {
        return PervasivesU.failwith("todo");
      }
    }
    line.substring(4, line.length);
    var match$5 = takeAllIndented(4, lines$1);
    var token_1$4 = PervasivesU.failwith("todo");
    var token$5 = {
      TAG: "TableElement",
      col: 2,
      content: token_1$4
    };
    return {
            hd: token$5,
            tl: parse(match$5[1])
          };
  };
  Core__List.fromArray(it.split("\n"));
  return PervasivesU.failwith("todo");
}

function parseParagraph(it) {
  var makeRecParser = function (k, delim, tag) {
    return function (it) {
      return it.split(delim.concat(delim)).flatMap(function (x, i) {
                  var x$1 = k(x.replaceAll(" ".concat(delim), delim));
                  if (i === 0) {
                    return x$1;
                  } else {
                    return Belt_Array.concatMany([
                                [{
                                    TAG: "Tag",
                                    _0: tag
                                  }],
                                x$1
                              ]);
                  }
                });
    };
  };
  var parseRec = makeRecParser(makeRecParser(makeRecParser(makeRecParser(makeRecParser(makeRecParser((function (x) {
                              return [{
                                        TAG: "Final",
                                        _0: {
                                          TAG: "Plain",
                                          _0: x
                                        }
                                      }];
                            }), "/", "Italic"), "*", "Strong"), "~", "Delete"), "!", "Highlight"), "_", "Underline"), "`", "Monospace");
  var tokens = it.split("\"\"").flatMap(function (token, i) {
        if (i % 2 === 0) {
          return parseRec(token);
        } else {
          return [{
                    TAG: "Final",
                    _0: {
                      TAG: "SEval",
                      _0: token
                    }
                  }];
        }
      });
  var splitAtFirst = function (ts, tag) {
    if (!ts) {
      return PervasivesU.failwith("not found");
    }
    var ts$1 = ts.tl;
    var t = ts.hd;
    if (Caml_obj.equal(t, {
            TAG: "Tag",
            _0: tag
          })) {
      return [
              /* [] */0,
              ts$1
            ];
    }
    var match = splitAtFirst(ts$1, tag);
    return [
            {
              hd: t,
              tl: match[0]
            },
            match[1]
          ];
  };
  var f = function (ts) {
    if (!ts) {
      return /* [] */0;
    }
    var x = ts.hd;
    if (x.TAG !== "Tag") {
      return {
              hd: x._0,
              tl: f(ts.tl)
            };
    }
    var t = x._0;
    var match = splitAtFirst(ts.tl, t);
    return {
            hd: {
              TAG: "Tagged",
              _0: t,
              _1: f(match[0])
            },
            tl: f(match[1])
          };
  };
  return f(Core__List.fromArray(tokens));
}

function $$escape(x) {
  return x.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#39;");
}

function spansToString(spans) {
  return Core__List.toArray(Core__List.map(spans, spanToString)).join("");
}

function spanToString(span) {
  switch (span.TAG) {
    case "Tagged" :
        var tag = Concepts.Tag.toString(span._0);
        return "<" + tag + ">" + spansToString(span._1) + "</" + tag + ">";
    case "SEval" :
        var tag$1 = "code";
        return "<" + tag$1 + ">" + $$escape(span._0) + "</" + tag$1 + ">";
    case "Plain" :
        return $$escape(span._0);
    
  }
}

export {
  parseDocument ,
  parseParagraph ,
  $$escape ,
  spansToString ,
  spanToString ,
}
/* No side effect */
