// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Concepts$Markright from "./Concepts.res.mjs";

function takeWhile(xs, f) {
  if (!xs) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  var y = f(x);
  if (y === undefined) {
    return [
            /* [] */0,
            {
              hd: x,
              tl: xs$1
            }
          ];
  }
  var match = takeWhile(xs$1, f);
  return [
          {
            hd: Caml_option.valFromOption(y),
            tl: match[0]
          },
          match[1]
        ];
}

function makeSpanParser(k, delim, tag) {
  return function (it) {
    return it.split(delim.concat(delim)).flatMap(function (x, i) {
                var x$1 = k(x.replaceAll(" ".concat(delim), delim));
                if (i === 0) {
                  return x$1;
                } else {
                  return Belt_Array.concatMany([
                              [{
                                  TAG: "Tag",
                                  _0: tag
                                }],
                              x$1
                            ]);
                }
              });
  };
}

var parseSpan = makeSpanParser(makeSpanParser(makeSpanParser(makeSpanParser(makeSpanParser(makeSpanParser((function (x) {
                            return [{
                                      TAG: "Final",
                                      _0: {
                                        TAG: "Plain",
                                        _0: x
                                      }
                                    }];
                          }), "/", "Oblique"), "*", "Boldface"), "`", "Monospaced"), "^", "Highlighted"), "_", "Underscored"), "~", "Strikethrough");

function parseParagraph(it) {
  var tokens = it.split("==").flatMap(function (token, i) {
        if (i % 2 === 0) {
          return parseSpan(token);
        } else {
          return [{
                    TAG: "Final",
                    _0: {
                      TAG: "EmbededS",
                      _0: token
                    }
                  }];
        }
      });
  var splitAtFirst = function (ts, tag) {
    if (!ts) {
      return PervasivesU.failwith("not found");
    }
    var ts$1 = ts.tl;
    var t = ts.hd;
    if (Caml_obj.equal(t, {
            TAG: "Tag",
            _0: tag
          })) {
      return [
              /* [] */0,
              ts$1
            ];
    }
    var match = splitAtFirst(ts$1, tag);
    return [
            {
              hd: t,
              tl: match[0]
            },
            match[1]
          ];
  };
  var f = function (ts) {
    if (!ts) {
      return /* [] */0;
    }
    var x = ts.hd;
    if (x.TAG !== "Tag") {
      return {
              hd: x._0,
              tl: f(ts.tl)
            };
    }
    var t = x._0;
    var match = splitAtFirst(ts.tl, t);
    return {
            hd: {
              TAG: "Tagged",
              _0: t,
              _1: f(match[0])
            },
            tl: f(match[1])
          };
  };
  return f(Core__List.fromArray(tokens));
}

function takeAllIndented(indent, lines) {
  if (!lines) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var lines$1 = lines.tl;
  var line = lines.hd;
  if (!(line === "" || line.startsWith(" ".repeat(indent)))) {
    return [
            /* [] */0,
            {
              hd: line,
              tl: lines$1
            }
          ];
  }
  var line$1 = line.substring(indent, line.length);
  var match = takeAllIndented(indent, lines$1);
  var lines$2 = match[1];
  var head = match[0];
  if (head === /* [] */0 && line$1 === "") {
    return [
            /* [] */0,
            {
              hd: line$1,
              tl: lines$2
            }
          ];
  } else {
    return [
            {
              hd: line$1,
              tl: head
            },
            lines$2
          ];
  }
}

function makeTable(es) {
  var collectRows = function (_row, _es) {
    while(true) {
      var es = _es;
      var row = _row;
      if (es) {
        var cell = es.hd;
        if (cell !== undefined) {
          _es = es.tl;
          _row = {
            hd: Caml_option.valFromOption(cell),
            tl: row
          };
          continue ;
        }
        var row$1 = Core__List.reverse(row);
        return {
                hd: row$1,
                tl: collectRows(/* [] */0, es.tl)
              };
      }
      var row$2 = Core__List.reverse(row);
      return {
              hd: row$2,
              tl: /* [] */0
            };
    };
  };
  return collectRows(/* [] */0, es);
}

function groupLines(_ts) {
  while(true) {
    var ts = _ts;
    if (!ts) {
      return /* [] */0;
    }
    var line = ts.hd;
    if (typeof line !== "object") {
      if (line === "TableBreak") {
        var match = takeWhile(ts.tl, (function (t) {
                if (typeof t !== "object") {
                  if (t === "TableBreak") {
                    return Caml_option.some(undefined);
                  } else {
                    return ;
                  }
                }
                if (t.TAG !== "SubDocument") {
                  return ;
                }
                var tmp = t._0;
                if (typeof tmp !== "object" && tmp === "TableElement") {
                  return Caml_option.some(t._1);
                }
                
              }));
        return {
                hd: {
                  TAG: "Table",
                  _0: makeTable(match[0])
                },
                tl: groupLines(match[1])
              };
      }
      _ts = ts.tl;
      continue ;
    } else {
      switch (line.TAG) {
        case "ParagraphLine" :
            var match$1 = takeWhile(ts.tl, (function (t) {
                    if (typeof t !== "object" || t.TAG !== "ParagraphLine") {
                      return ;
                    } else {
                      return t._0;
                    }
                  }));
            var es_0 = line._0;
            var es_1 = match$1[0];
            var es = {
              hd: es_0,
              tl: es_1
            };
            return {
                    hd: {
                      TAG: "Paragraph",
                      _0: parseParagraph(Core__List.toArray(es).join(" "))
                    },
                    tl: groupLines(match$1[1])
                  };
        case "SubDocument" :
            var checked = line._0;
            if (typeof checked !== "object") {
              switch (checked) {
                case "OrderedList" :
                    var match$2 = takeWhile(ts.tl, (function (t) {
                            if (typeof t !== "object") {
                              return ;
                            }
                            if (t.TAG !== "SubDocument") {
                              return ;
                            }
                            var tmp = t._0;
                            if (typeof tmp !== "object" && tmp === "OrderedList") {
                              return t._1;
                            }
                            
                          }));
                    var es_0$1 = line._1;
                    var es_1$1 = match$2[0];
                    var es$1 = {
                      hd: es_0$1,
                      tl: es_1$1
                    };
                    return {
                            hd: {
                              TAG: "OrderedList",
                              _0: es$1
                            },
                            tl: groupLines(match$2[1])
                          };
                case "UnorderedList" :
                    var match$3 = takeWhile(ts.tl, (function (t) {
                            if (typeof t !== "object") {
                              return ;
                            }
                            if (t.TAG !== "SubDocument") {
                              return ;
                            }
                            var tmp = t._0;
                            if (typeof tmp !== "object" && tmp === "UnorderedList") {
                              return t._1;
                            }
                            
                          }));
                    var es_0$2 = line._1;
                    var es_1$2 = match$3[0];
                    var es$2 = {
                      hd: es_0$2,
                      tl: es_1$2
                    };
                    return {
                            hd: {
                              TAG: "UnorderedList",
                              _0: es$2
                            },
                            tl: groupLines(match$3[1])
                          };
                case "TableElement" :
                    var match$4 = takeWhile(ts.tl, (function (t) {
                            if (typeof t !== "object") {
                              if (t === "TableBreak") {
                                return Caml_option.some(undefined);
                              } else {
                                return ;
                              }
                            }
                            if (t.TAG !== "SubDocument") {
                              return ;
                            }
                            var tmp = t._0;
                            if (typeof tmp !== "object" && tmp === "TableElement") {
                              return Caml_option.some(t._1);
                            }
                            
                          }));
                    var es_0$3 = line._1;
                    var es_1$3 = match$4[0];
                    var es$3 = {
                      hd: es_0$3,
                      tl: es_1$3
                    };
                    return {
                            hd: {
                              TAG: "Table",
                              _0: makeTable(es$3)
                            },
                            tl: groupLines(match$4[1])
                          };
                
              }
            } else {
              var match$5 = takeWhile(ts.tl, (function (t) {
                      if (typeof t !== "object") {
                        return ;
                      }
                      if (t.TAG !== "SubDocument") {
                        return ;
                      }
                      var checked = t._0;
                      if (typeof checked !== "object") {
                        return ;
                      } else {
                        return [
                                checked._0,
                                t._1
                              ];
                      }
                    }));
              var es_0$4 = [
                checked._0,
                line._1
              ];
              var es_1$4 = match$5[0];
              var es$4 = {
                hd: es_0$4,
                tl: es_1$4
              };
              return {
                      hd: {
                        TAG: "CheckList",
                        _0: es$4
                      },
                      tl: groupLines(match$5[1])
                    };
            }
        case "FinalB" :
            return {
                    hd: line._0,
                    tl: groupLines(ts.tl)
                  };
        
      }
    }
  };
}

function parseDocument(it) {
  var parse = function (lines) {
    if (!lines) {
      return /* [] */0;
    }
    var lines$1 = lines.tl;
    var line = lines.hd;
    var tryParseSubBlock = function (mark, subblock) {
      if (!line.startsWith(mark.concat(" "))) {
        return ;
      }
      var line$1 = line.substring(2, line.length);
      var match = takeAllIndented(2, lines$1);
      var token = subblock({
            hd: line$1,
            tl: match[0]
          });
      return {
              hd: token,
              tl: parse(match[1])
            };
    };
    var tryParseSubDocument = function (mark, subdoc) {
      return tryParseSubBlock(mark, (function (b) {
                    return subdoc(parseDocument$1(b));
                  }));
    };
    return Core__Option.getOr(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(Core__Option.orElse(undefined, tryParseSubDocument("#", (function (d) {
                                                                  return {
                                                                          TAG: "FinalB",
                                                                          _0: {
                                                                            TAG: "Heading1",
                                                                            _0: d
                                                                          }
                                                                        };
                                                                }))), tryParseSubDocument("##", (function (d) {
                                                              return {
                                                                      TAG: "FinalB",
                                                                      _0: {
                                                                        TAG: "Heading2",
                                                                        _0: d
                                                                      }
                                                                    };
                                                            }))), tryParseSubDocument("###", (function (d) {
                                                          return {
                                                                  TAG: "FinalB",
                                                                  _0: {
                                                                    TAG: "Heading3",
                                                                    _0: d
                                                                  }
                                                                };
                                                        }))), tryParseSubDocument(">", (function (d) {
                                                      return {
                                                              TAG: "FinalB",
                                                              _0: {
                                                                TAG: "Heading2",
                                                                _0: d
                                                              }
                                                            };
                                                    }))), tryParseSubDocument(".", (function (d) {
                                                  return {
                                                          TAG: "SubDocument",
                                                          _0: "OrderedList",
                                                          _1: d
                                                        };
                                                }))), tryParseSubDocument("-", (function (d) {
                                              return {
                                                      TAG: "SubDocument",
                                                      _0: "UnorderedList",
                                                      _1: d
                                                    };
                                            }))), tryParseSubDocument("o", (function (d) {
                                          return {
                                                  TAG: "SubDocument",
                                                  _0: {
                                                    TAG: "CheckList",
                                                    _0: false
                                                  },
                                                  _1: d
                                                };
                                        }))), tryParseSubDocument("x", (function (d) {
                                      return {
                                              TAG: "SubDocument",
                                              _0: {
                                                TAG: "CheckList",
                                                _0: true
                                              },
                                              _1: d
                                            };
                                    }))), tryParseSubDocument("|", (function (d) {
                                  return {
                                          TAG: "SubDocument",
                                          _0: "TableElement",
                                          _1: d
                                        };
                                }))), tryParseSubDocument(".", (function (d) {
                              return {
                                      TAG: "SubDocument",
                                      _0: "OrderedList",
                                      _1: d
                                    };
                            }))), tryParseSubBlock("=", (function (d) {
                          return {
                                  TAG: "FinalB",
                                  _0: {
                                    TAG: "EmbededB",
                                    _0: Core__List.toArray(d).join("\n")
                                  }
                                };
                        }))), {
                hd: /^\w*$/g.test(line) ? "Empty" : (
                    "|-" === line ? "TableBreak" : ({
                          TAG: "ParagraphLine",
                          _0: line
                        })
                  ),
                tl: parse(lines$1)
              });
  };
  var parseDocument$1 = function (lines) {
    var lines$1 = parse(lines);
    return groupLines(lines$1);
  };
  return parseDocument$1(Core__List.fromArray(it.split("\n")));
}

function $$escape(x) {
  return x.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#39;");
}

function spansToString(spans) {
  return Core__List.toArray(Core__List.map(spans, spanToString)).join("");
}

function spanToString(span) {
  switch (span.TAG) {
    case "Tagged" :
        var tag = Concepts$Markright.Tag.toString(span._0);
        return "<" + tag + ">" + spansToString(span._1) + "</" + tag + ">";
    case "EmbededS" :
        var tag$1 = "code";
        return "<" + tag$1 + ">" + $$escape(span._0) + "</" + tag$1 + ">";
    case "Plain" :
        return $$escape(span._0);
    
  }
}

function blockToString(block) {
  switch (block.TAG) {
    case "Heading1" :
        return "<h1>" + documentToString(block._0) + "</h1>";
    case "Heading2" :
        return "<h2>" + documentToString(block._0) + "</h2>";
    case "Heading3" :
        return "<h3>" + documentToString(block._0) + "</h3>";
    case "OrderedList" :
        return listToString(true, block._0);
    case "UnorderedList" :
        return listToString(false, block._0);
    case "CheckList" :
        var content = Core__List.map(block._0, (function (param) {
                return [
                        param[0],
                        documentToString(param[1])
                      ];
              }));
        return "<ul>" + Core__List.toArray(Core__List.map(content, (function (param) {
                            return "<li><input type=\"checkbox\" " + (
                                    param[0] ? "checked" : ""
                                  ) + ">" + param[1] + "</li>";
                          }))).join("") + "</ul>";
    case "Table" :
        var content$1 = Core__List.toArray(Core__List.map(block._0, tableRowToString)).join("");
        return "<table>" + content$1 + "</table>";
    case "Quotation" :
        var tag = "Quotation";
        var content$2 = documentToString(block._0);
        return "<" + tag + ">" + content$2 + "</" + tag + ">";
    case "EmbededB" :
        return PervasivesU.failwith("todo");
    case "Paragraph" :
        return "<p>" + spansToString(block._0) + "</p>";
    
  }
}

function listToString(ordered, content) {
  var tag = ordered ? "ol" : "ul";
  var content$1 = Core__List.toArray(Core__List.map(Core__List.map(content, documentToString), (function (x) {
                return "<li>" + x + "</li>";
              }))).join("");
  return "<" + tag + ">" + content$1 + "</" + tag + ">";
}

function tableRowToString(content) {
  var content$1 = Core__List.toArray(Core__List.map(content, tableCellToString)).join("");
  var tag = "tr";
  return "<" + tag + ">" + content$1 + "</" + tag + ">";
}

function tableCellToString(content) {
  return "<td>" + documentToString(content) + "</td>";
}

function documentToString($$document) {
  if ($$document) {
    var p = $$document.hd;
    if (p.TAG === "Paragraph" && !$$document.tl) {
      return spansToString(p._0);
    }
    
  }
  return Core__List.toArray(Core__List.map($$document, blockToString)).join("");
}

export {
  parseDocument ,
  documentToString ,
}
/* parseSpan Not a pure module */
