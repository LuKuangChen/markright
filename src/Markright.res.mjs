// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Markright__Concept$Markright from "./Markright__Concept.res.mjs";

function takeWhile(xs, f) {
  if (!xs) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  var y = f(x);
  if (y === undefined) {
    return [
            /* [] */0,
            {
              hd: x,
              tl: xs$1
            }
          ];
  }
  var match = takeWhile(xs$1, f);
  return [
          {
            hd: Caml_option.valFromOption(y),
            tl: match[0]
          },
          match[1]
        ];
}

function makeSpanParser(k, delim, tag) {
  return function (it) {
    return it.split(delim.concat(delim)).flatMap(function (x, i) {
                var x$1 = k(x.replaceAll(" ".concat(delim), delim));
                if (i === 0) {
                  return x$1;
                } else {
                  return Belt_Array.concatMany([
                              [{
                                  TAG: "Tag",
                                  _0: tag
                                }],
                              x$1
                            ]);
                }
              });
  };
}

var parseSpan = makeSpanParser(makeSpanParser(makeSpanParser(makeSpanParser(makeSpanParser(makeSpanParser((function (x) {
                            return [{
                                      TAG: "Final",
                                      _0: {
                                        TAG: "Plain",
                                        _0: x
                                      }
                                    }];
                          }), "/", "Oblique"), "*", "Boldface"), "`", "Monospaced"), "^", "Highlighted"), "_", "Underscored"), "~", "Strikethrough");

function parseParagraph(it) {
  var tokens = it.split("==").flatMap(function (token, i) {
        if (i % 2 === 0) {
          return parseSpan(token);
        }
        var elements = token.split("|", 2);
        var match = elements[0];
        var match$1 = elements[1];
        if (match !== undefined) {
          if (match$1 !== undefined) {
            return [{
                      TAG: "Final",
                      _0: {
                        TAG: "Embeded",
                        _0: match,
                        _1: match$1
                      }
                    }];
          } else {
            return [{
                      TAG: "Final",
                      _0: {
                        TAG: "Embeded",
                        _0: match,
                        _1: ""
                      }
                    }];
          }
        } else {
          return PervasivesU.failwith("invalid embeding: " + token);
        }
      });
  var splitAtFirst = function (ts, tag) {
    if (!ts) {
      return PervasivesU.failwith("not found");
    }
    var ts$1 = ts.tl;
    var t = ts.hd;
    if (Caml_obj.equal(t, {
            TAG: "Tag",
            _0: tag
          })) {
      return [
              /* [] */0,
              ts$1
            ];
    }
    var match = splitAtFirst(ts$1, tag);
    return [
            {
              hd: t,
              tl: match[0]
            },
            match[1]
          ];
  };
  var f = function (ts) {
    if (!ts) {
      return /* [] */0;
    }
    var x = ts.hd;
    if (x.TAG !== "Tag") {
      return {
              hd: x._0,
              tl: f(ts.tl)
            };
    }
    var t = x._0;
    var match = splitAtFirst(ts.tl, t);
    return {
            hd: {
              TAG: "Tagged",
              _0: t,
              _1: f(match[0])
            },
            tl: f(match[1])
          };
  };
  return f(Core__List.fromArray(tokens));
}

function takeAllIndented(indent, lines) {
  if (!lines) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var lines$1 = lines.tl;
  var line = lines.hd;
  if (!(line === "" || line.startsWith(" ".repeat(indent)))) {
    return [
            /* [] */0,
            {
              hd: line,
              tl: lines$1
            }
          ];
  }
  var line$1 = line.substring(indent, line.length);
  var match = takeAllIndented(indent, lines$1);
  var lines$2 = match[1];
  var head = match[0];
  if (head === /* [] */0 && line$1 === "") {
    return [
            /* [] */0,
            {
              hd: line$1,
              tl: lines$2
            }
          ];
  } else {
    return [
            {
              hd: line$1,
              tl: head
            },
            lines$2
          ];
  }
}

function makeTable(es) {
  var collectRows = function (_row, _es) {
    while(true) {
      var es = _es;
      var row = _row;
      if (es) {
        var cell = es.hd;
        if (cell !== undefined) {
          _es = es.tl;
          _row = {
            hd: Caml_option.valFromOption(cell),
            tl: row
          };
          continue ;
        }
        var row$1 = Core__List.reverse(row);
        return {
                hd: row$1,
                tl: collectRows(/* [] */0, es.tl)
              };
      }
      var row$2 = Core__List.reverse(row);
      return {
              hd: row$2,
              tl: /* [] */0
            };
    };
  };
  return collectRows(/* [] */0, es);
}

function groupLines(_ts) {
  while(true) {
    var ts = _ts;
    if (!ts) {
      return /* [] */0;
    }
    var line = ts.hd;
    if (typeof line !== "object") {
      if (line === "TableBreak") {
        var match = takeWhile(ts.tl, (function (t) {
                if (typeof t !== "object") {
                  if (t === "TableBreak") {
                    return Caml_option.some(undefined);
                  } else {
                    return ;
                  }
                }
                if (t.TAG !== "SubDocument") {
                  return ;
                }
                var tmp = t._0;
                if (typeof tmp !== "object" && tmp === "TableElement") {
                  return Caml_option.some(t._1);
                }
                
              }));
        return {
                hd: {
                  TAG: "Table",
                  _0: makeTable(match[0])
                },
                tl: groupLines(match[1])
              };
      }
      _ts = ts.tl;
      continue ;
    } else {
      switch (line.TAG) {
        case "ParagraphLine" :
            var match$1 = takeWhile(ts.tl, (function (t) {
                    if (typeof t !== "object" || t.TAG !== "ParagraphLine") {
                      return ;
                    } else {
                      return t._0;
                    }
                  }));
            var es_0 = line._0;
            var es_1 = match$1[0];
            var es = {
              hd: es_0,
              tl: es_1
            };
            return {
                    hd: {
                      TAG: "Paragraph",
                      _0: parseParagraph(Core__List.toArray(es).join(" "))
                    },
                    tl: groupLines(match$1[1])
                  };
        case "SubDocument" :
            var checked = line._0;
            if (typeof checked !== "object") {
              switch (checked) {
                case "OrderedList" :
                    var match$2 = takeWhile(ts.tl, (function (t) {
                            if (typeof t !== "object") {
                              return ;
                            }
                            if (t.TAG !== "SubDocument") {
                              return ;
                            }
                            var tmp = t._0;
                            if (typeof tmp !== "object" && tmp === "OrderedList") {
                              return t._1;
                            }
                            
                          }));
                    var es_0$1 = line._1;
                    var es_1$1 = match$2[0];
                    var es$1 = {
                      hd: es_0$1,
                      tl: es_1$1
                    };
                    return {
                            hd: {
                              TAG: "OrderedList",
                              _0: es$1
                            },
                            tl: groupLines(match$2[1])
                          };
                case "UnorderedList" :
                    var match$3 = takeWhile(ts.tl, (function (t) {
                            if (typeof t !== "object") {
                              return ;
                            }
                            if (t.TAG !== "SubDocument") {
                              return ;
                            }
                            var tmp = t._0;
                            if (typeof tmp !== "object" && tmp === "UnorderedList") {
                              return t._1;
                            }
                            
                          }));
                    var es_0$2 = line._1;
                    var es_1$2 = match$3[0];
                    var es$2 = {
                      hd: es_0$2,
                      tl: es_1$2
                    };
                    return {
                            hd: {
                              TAG: "UnorderedList",
                              _0: es$2
                            },
                            tl: groupLines(match$3[1])
                          };
                case "TableElement" :
                    var match$4 = takeWhile(ts.tl, (function (t) {
                            if (typeof t !== "object") {
                              if (t === "TableBreak") {
                                return Caml_option.some(undefined);
                              } else {
                                return ;
                              }
                            }
                            if (t.TAG !== "SubDocument") {
                              return ;
                            }
                            var tmp = t._0;
                            if (typeof tmp !== "object" && tmp === "TableElement") {
                              return Caml_option.some(t._1);
                            }
                            
                          }));
                    var es_0$3 = line._1;
                    var es_1$3 = match$4[0];
                    var es$3 = {
                      hd: es_0$3,
                      tl: es_1$3
                    };
                    return {
                            hd: {
                              TAG: "Table",
                              _0: makeTable(es$3)
                            },
                            tl: groupLines(match$4[1])
                          };
                
              }
            } else {
              var match$5 = takeWhile(ts.tl, (function (t) {
                      if (typeof t !== "object") {
                        return ;
                      }
                      if (t.TAG !== "SubDocument") {
                        return ;
                      }
                      var checked = t._0;
                      if (typeof checked !== "object") {
                        return ;
                      } else {
                        return [
                                checked._0,
                                t._1
                              ];
                      }
                    }));
              var es_0$4 = [
                checked._0,
                line._1
              ];
              var es_1$4 = match$5[0];
              var es$4 = {
                hd: es_0$4,
                tl: es_1$4
              };
              return {
                      hd: {
                        TAG: "CheckList",
                        _0: es$4
                      },
                      tl: groupLines(match$5[1])
                    };
            }
        case "Final" :
            return {
                    hd: line._0,
                    tl: groupLines(ts.tl)
                  };
        
      }
    }
  };
}

function orElse(fst, snd) {
  if (fst !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(fst));
  } else {
    return snd();
  }
}

function parseDocument(it) {
  var parse = function (lines) {
    if (!lines) {
      return /* [] */0;
    }
    var lines$1 = lines.tl;
    var line = lines.hd;
    var tryParseSubBlock = function (mark, subblock) {
      if (!line.startsWith(mark.concat(" "))) {
        return ;
      }
      var line$1 = line.substring(1 + mark.length | 0, line.length);
      var match = takeAllIndented(2, lines$1);
      var block_1 = match[0];
      var block = {
        hd: line$1,
        tl: block_1
      };
      var token = subblock(block);
      return {
              hd: token,
              tl: parse(match[1])
            };
    };
    var tryParseSubDocument = function (mark, subdoc) {
      return tryParseSubBlock(mark, (function (b) {
                    return subdoc(parseDocument$1(b));
                  }));
    };
    var fst = orElse(orElse(orElse(orElse(orElse(orElse(orElse(orElse(orElse(tryParseSubDocument("#", (function (d) {
                                                return {
                                                        TAG: "Final",
                                                        _0: {
                                                          TAG: "Heading1",
                                                          _0: d
                                                        }
                                                      };
                                              })), (function () {
                                            return tryParseSubDocument("##", (function (d) {
                                                          return {
                                                                  TAG: "Final",
                                                                  _0: {
                                                                    TAG: "Heading2",
                                                                    _0: d
                                                                  }
                                                                };
                                                        }));
                                          })), (function () {
                                        return tryParseSubDocument("###", (function (d) {
                                                      return {
                                                              TAG: "Final",
                                                              _0: {
                                                                TAG: "Heading3",
                                                                _0: d
                                                              }
                                                            };
                                                    }));
                                      })), (function () {
                                    return tryParseSubDocument(">", (function (d) {
                                                  return {
                                                          TAG: "Final",
                                                          _0: {
                                                            TAG: "Quotation",
                                                            _0: d
                                                          }
                                                        };
                                                }));
                                  })), (function () {
                                return tryParseSubDocument(".", (function (d) {
                                              return {
                                                      TAG: "SubDocument",
                                                      _0: "OrderedList",
                                                      _1: d
                                                    };
                                            }));
                              })), (function () {
                            return tryParseSubDocument("-", (function (d) {
                                          return {
                                                  TAG: "SubDocument",
                                                  _0: "UnorderedList",
                                                  _1: d
                                                };
                                        }));
                          })), (function () {
                        return tryParseSubDocument("o", (function (d) {
                                      return {
                                              TAG: "SubDocument",
                                              _0: {
                                                TAG: "CheckList",
                                                _0: false
                                              },
                                              _1: d
                                            };
                                    }));
                      })), (function () {
                    return tryParseSubDocument("x", (function (d) {
                                  return {
                                          TAG: "SubDocument",
                                          _0: {
                                            TAG: "CheckList",
                                            _0: true
                                          },
                                          _1: d
                                        };
                                }));
                  })), (function () {
                return tryParseSubDocument("|", (function (d) {
                              return {
                                      TAG: "SubDocument",
                                      _0: "TableElement",
                                      _1: d
                                    };
                            }));
              })), (function () {
            return tryParseSubBlock("=", (function (d) {
                          var tmp;
                          if (d) {
                            var x = Core__List.toArray(d.tl).join("\n");
                            tmp = {
                              TAG: "Embeded",
                              _0: d.hd,
                              _1: x
                            };
                          } else {
                            tmp = PervasivesU.failwith("invalid embedding");
                          }
                          return {
                                  TAG: "Final",
                                  _0: tmp
                                };
                        }));
          }));
    var snd = function () {
      return {
              hd: /^\s*$/g.test(line) ? "Empty" : (
                  "|-" === line ? "TableBreak" : ({
                        TAG: "ParagraphLine",
                        _0: line
                      })
                ),
              tl: parse(lines$1)
            };
    };
    if (fst !== undefined) {
      return Caml_option.valFromOption(fst);
    } else {
      return snd();
    }
  };
  var parseDocument$1 = function (lines) {
    var lines$1 = parse(lines);
    return groupLines(lines$1);
  };
  return parseDocument$1(Core__List.fromArray(it.split("\n")));
}

function asSpans($$document) {
  if (!$$document) {
    return /* [] */0;
  }
  var x = $$document.hd;
  switch (x.TAG) {
    case "Paragraph" :
        if ($$document.tl) {
          return PervasivesU.failwith("Expecting spans");
        } else {
          return x._0;
        }
    case "Raw" :
        if ($$document.tl) {
          return PervasivesU.failwith("Expecting spans");
        } else {
          return {
                  hd: {
                    TAG: "Raw",
                    _0: x._0
                  },
                  tl: /* [] */0
                };
        }
    default:
      return PervasivesU.failwith("Expecting spans");
  }
}

var evaluator = Object.fromEntries([
      [
        "raw",
        (function (content, param) {
            return {
                    hd: {
                      TAG: "Paragraph",
                      _0: {
                        hd: {
                          TAG: "Raw",
                          _0: content
                        },
                        tl: /* [] */0
                      }
                    },
                    tl: /* [] */0
                  };
          })
      ],
      [
        "now",
        (function (_content, param) {
            var x = new Date().toISOString();
            return {
                    hd: {
                      TAG: "Paragraph",
                      _0: {
                        hd: {
                          TAG: "Plain",
                          _0: x
                        },
                        tl: /* [] */0
                      }
                    },
                    tl: /* [] */0
                  };
          })
      ],
      [
        "toc",
        (function (param, $$document) {
            return {
                    hd: {
                      TAG: "OrderedList",
                      _0: Core__List.filterMap(Core__List.mapWithIndex($$document, (function (b, i) {
                                  if (b.TAG !== "Heading2") {
                                    return ;
                                  }
                                  var subsectionsOf = function (_bs) {
                                    while(true) {
                                      var bs = _bs;
                                      if (!bs) {
                                        return /* [] */0;
                                      }
                                      var d = bs.hd;
                                      switch (d.TAG) {
                                        case "Heading2" :
                                            return /* [] */0;
                                        case "Heading3" :
                                            return {
                                                    hd: d._0,
                                                    tl: subsectionsOf(bs.tl)
                                                  };
                                        default:
                                          _bs = bs.tl;
                                          continue ;
                                      }
                                    };
                                  };
                                  return Belt_List.concatMany([
                                              b._0,
                                              {
                                                hd: {
                                                  TAG: "OrderedList",
                                                  _0: subsectionsOf(Core__Option.getOr(Core__List.drop($$document, i + 1 | 0), /* [] */0))
                                                },
                                                tl: /* [] */0
                                              }
                                            ]);
                                })), (function (v) {
                              return v;
                            }))
                    },
                    tl: /* [] */0
                  };
          })
      ]
    ]);

function compile($$document, extensionsOpt) {
  var extensions = extensionsOpt !== undefined ? extensionsOpt : ({});
  var $$document$1 = parseDocument($$document);
  var extensionsOpt$1 = extensions;
  var extensions$1 = extensionsOpt$1 !== undefined ? extensionsOpt$1 : ({});
  var evaluate = function (f, content) {
    var f$1 = Core__Option.orElse(extensions$1[f], evaluator[f]);
    if (f$1 !== undefined) {
      return f$1(content, $$document$1);
    } else {
      return PervasivesU.failwith("Unknown evaluator " + f);
    }
  };
  var spansToString = function (spans) {
    return Core__List.toArray(Core__List.map(spans, spanToString)).join("");
  };
  var spanToString = function (span) {
    switch (span.TAG) {
      case "Tagged" :
          var tag = Markright__Concept$Markright.Tag.toHTMLString(span._0);
          return "<" + tag + ">" + spansToString(span._1) + "</" + tag + ">";
      case "Embeded" :
          return spansToString(asSpans(evaluate(span._0, span._1)));
      case "Plain" :
          var x = span._0;
          return x.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#39;");
      case "Raw" :
          return span._0;
      
    }
  };
  var blockToString = function (block) {
    switch (block.TAG) {
      case "Heading1" :
          return "<h1>" + documentToString(block._0) + "</h1>";
      case "Heading2" :
          return "<h2>" + documentToString(block._0) + "</h2>";
      case "Heading3" :
          return "<h3>" + documentToString(block._0) + "</h3>";
      case "OrderedList" :
          return listToString(true, block._0);
      case "UnorderedList" :
          return listToString(false, block._0);
      case "CheckList" :
          var content = Core__List.map(block._0, (function (param) {
                  return [
                          param[0],
                          documentToString(param[1])
                        ];
                }));
          return "<ul>" + Core__List.toArray(Core__List.map(content, (function (param) {
                              return "<li><input type=\"checkbox\" " + (
                                      param[0] ? "checked" : ""
                                    ) + ">" + param[1] + "</li>";
                            }))).join("") + "</ul>";
      case "Table" :
          var content$1 = Core__List.toArray(Core__List.map(block._0, tableRowToString)).join("");
          return "<table>" + content$1 + "</table>";
      case "Quotation" :
          var tag = "blockquote";
          var content$2 = documentToString(block._0);
          return "<" + tag + ">" + content$2 + "</" + tag + ">";
      case "Embeded" :
          return documentToString(evaluate(block._0, block._1));
      case "Paragraph" :
          return "<p>" + spansToString(block._0) + "</p>";
      case "Raw" :
          return block._0;
      
    }
  };
  var listToString = function (ordered, content) {
    var tag = ordered ? "ol" : "ul";
    var content$1 = Core__List.toArray(Core__List.map(Core__List.map(content, documentToString), (function (x) {
                  return "<li>" + x + "</li>";
                }))).join("");
    return "<" + tag + ">" + content$1 + "</" + tag + ">";
  };
  var tableRowToString = function (content) {
    var content$1 = Core__List.toArray(Core__List.map(content, tableCellToString)).join("");
    var tag = "tr";
    return "<" + tag + ">" + content$1 + "</" + tag + ">";
  };
  var tableCellToString = function (content) {
    return "<td>" + documentToString(content) + "</td>";
  };
  var documentToString = function ($$document) {
    if ($$document) {
      var p = $$document.hd;
      if (p.TAG === "Paragraph" && !$$document.tl) {
        return spansToString(p._0);
      }
      
    }
    return Core__List.toArray(Core__List.map($$document, blockToString)).join("");
  };
  return documentToString($$document$1);
}

var Concept;

var Extension;

export {
  Concept ,
  Extension ,
  compile ,
}
/* parseSpan Not a pure module */
